From b55ba25049ecdcd8baa09c9bb6e09089da2e652e Mon Sep 17 00:00:00 2001
From: Raphael Mounier <mounierr07@gmail.com>
Date: Thu, 5 Oct 2023 08:56:58 +0200
Subject: [PATCH] audio flinger: fix audio on emui8/9 by changing hw_module
 value

Change-Id: I83f4d7d09d374c4930389258f97fcd63844436b8
---
 services/audioflinger/Threads.cpp | 46 ++++++++++++++++++++++++++++---
 1 file changed, 42 insertions(+), 4 deletions(-)

diff --git a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
index 73ee691226..43bbc8d312 100644
--- a/services/audioflinger/Threads.cpp
+++ b/services/audioflinger/Threads.cpp
@@ -4638,13 +4638,51 @@ status_t AudioFlinger::PlaybackThread::createAudioPatch_l(const struct audio_pat
     checkSilentMode_l();
 
     if (mOutput->audioHwDev->supportsAudioPatches()) {
+    	ALOGI("%s() thread suupport audio patch", __func__);
+        
+	// Special patch for old huawei device
+	// Store sources and sinks value
+	// Keep handle
+	// audio patch struct
+	
+	struct audio_patch new_patch;
+	audio_patch_handle_t handle_sources=AUDIO_PATCH_HANDLE_NONE;
+	audio_patch_handle_t handle_sink=AUDIO_PATCH_HANDLE_NONE;
+	
+	new_patch.num_sources = patch->num_sources;
+	new_patch.num_sinks = patch->num_sinks;
+	for (int i = 0; i < patch->num_sources; i++) {
+	    new_patch.sources[i] = patch->sources[i];
+            if (new_patch.sources[i].type == AUDIO_PORT_TYPE_MIX)
+                handle_sources=new_patch.sources[i].ext.mix.handle;
+	}
+	for (int i = 0; i < patch->num_sinks; i++) {
+	    new_patch.sinks[i] = patch->sinks[i];
+            if (new_patch.sinks[i].type == AUDIO_PORT_TYPE_MIX)
+                handle_sink=new_patch.sinks[i].ext.mix.handle;
+	}
+
+        ALOGI("%s() Audio Handle Source %d", __func__, handle_sources);
+        ALOGI("%s() Audio Handle sink %d", __func__, handle_sink);
+	
+	// replace hw_module by my current value
+	// AidlConversion: aidl2legacy_AudioPortMixExt: hw_module 10 - handle 13
+	// AidlConversion: legacy2aidl_AudioPortMixExt: hw_module 10 - handle 13
+	for (int i = 0; i < new_patch.num_sources; i++)
+		new_patch.sources[i].ext.mix.hw_module=handle_sources;
+
+	//for (int i = 0; i < new_patch.num_sinks; i++)
+	//	new_patch.sinks[i].ext.device.hw_module=handle_sources;
+
+        
         sp<DeviceHalInterface> hwDevice = mOutput->audioHwDev->hwDevice();
-        status = hwDevice->createAudioPatch(patch->num_sources,
-                                            patch->sources,
-                                            patch->num_sinks,
-                                            patch->sinks,
+        status = hwDevice->createAudioPatch(new_patch.num_sources,
+                                            new_patch.sources,
+                                            new_patch.num_sinks,
+                                            new_patch.sinks,
                                             handle);
     } else {
+    	ALOGI("%s() thread create legacy audio patch", __func__);
         status = mOutput->stream->legacyCreateAudioPatch(patch->sinks[0], std::nullopt, type);
         *handle = AUDIO_PATCH_HANDLE_NONE;
     }
-- 
2.25.1

